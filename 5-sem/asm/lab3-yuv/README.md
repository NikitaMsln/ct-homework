# Лабораторная 3: RGB <-> YUV

Написать две функции: выполняющие преобразование изображения из цветового пространства RGB в YUV (YCbCr 601, PC-range) и обратно. Для вычислений использовать целочисленную арифметику (фиксированную точку) и SIMD-команды.

Прототипы функций:

```cpp
void RGB2YUV(const uint8_t *in, uint8_t *restrict out, size_t width, size_t height, ptrdiff_t in_stride, ptrdiff_t out_stride);
void YUV2RGB(const uint8_t *in, uint8_t *restrict out, size_t width, size_t height, ptrdiff_t in_stride, ptrdiff_t out_stride);
```

`_stride` – расстояние (в байтах, со знаком) между первой точкой одной строки и первой точкой следующей строки.

RGB данные лежат в памяти в порядке: R G B R G B...<br/>
YUV данные лежат в памяти в порядке: Y U V X Y U V X... , где X – произвольное значение (0 при записи, не учитывается при чтении).

Преобразования RGB <=> YUV строить исходя из параметров:<br/>
`Kr = 0.298839`<br/>
`Kb = 0.114350`

## Требования к реализации

64-битный код, конвенция вызова: fastcall64. За указанные размеры буферов выходить нельзя.

Функции должны быть реализованы в одном файле `convert.asm` и не использовать каких-либо внешних функций (использовать свои дополнительные функции в том же файле – разрешается).

Разрешается использовать любые расширения команд, поддерживаемые процессорами архитектуры Skylake (стоит на сервере).

В репозиторий необходимо загрузить только один `.asm`-файл. Загружать дополнительные файлы, например, со своими тестами, CMakeLists.txt и пр. не запрещено, но при проверке они учитываться не будут.

В репозитории лежит `tmain.c`, который используется в автотестах - его нельзя удалять/перемещать и как-то модифицировать.

## Отправка на проверку

1. Необходимо загрузить `.asm`-файл с кодом на `main`. Обратите внимание, проверяется код, лежащий только на ветке `main`.
2. Запустить автотесты и дождаться результатов. `/* Запуск CI/CD #1 by github-classroom-bot игнорируйте */`
3. В уже созданном Pull Request 'Feedback' оставить комментарии, если их важно знать проверяющему.
4. Поставить в Reviewers [SEt-t](https://github.com/SEt-t).
5. Дождаться результатов проверки и прочитать результат проверки.

## Автотесты

Отличный способ проверить, что вы загрузили в репозиторий работоспособный код.

### Запуск автотестов

Запускать автотесты можно как через web-интерфейс, так и с использванием [gh API](https://cli.github.com/manual/gh\_workflow\_run) (имя .yaml файла можно найти в репозитории в `.github/workflow`):

CLI:

```
gh workflow run classroom.yml --ref main
```

Web:

1. Перейти в раздел Actions. Там выбрать workflow (CI/CD), после чего в меню запуска _Run workflow_ проставить галочки у тестов которые вы хотите запустить (если они есть).
2. Дождаться окончания запуска. Новый запуск (run) появляется в списке запусков с некоторой задержкой (до 10 секунд), так что наберитесь терпения или press F5.
3. Ознакомиться с результатами запуска.
    Summary по каждому запуску (job). Это отчет, который оформлен для вас в человекочитаемом виде.
    В Summary отображается статус проверки и ниже приводятся логи тестов на обеих системах.
   
